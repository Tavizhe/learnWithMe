# Laravel

## Pre Requirements

To start first install Xampp application then add php directory to your path in environment variables. Later check `php -v` in command line (CMD) to see the right version of php.

Next is time to install Composer. First download `Composer-Setup.exe` from [Composer Site](https://getcomposer.org/download/) then simply install it. After check composer version with Command Line with following command `composer -V`.

## Creating New Laravel Project Using Composer

To create a new project using Composer run in Command Line:

```shell
cd C:\xampp\htdocs
composer create-project laravel/laravel="*" Project_Name
# don't forget to add your exact php version instead of "*".
```

In order to use local host to check your made website use following command:

```shell
php artisan serve
```

by using this command in Command line or Power Shell (It's better to be used vscode terminal), an Host with an IP will be shown like `http://127.0.0.1:8000`. by clicking on it you will be directed to desired laravel website.

## Laravel Root Directory Structure

| Directory | Description                                                                                                                                    |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| app       | The app directory holds the base code for your Laravel application.                                                                            |
| bootstrap | The bootstrap directory contains all the bootstrapping scripts used for your application.                                                      |
| config    | The config directory holds all your project configuration files (.config).                                                                     |
| database  | The database directory contains your database files.                                                                                           |
| public    | The public directory helps start your Laravel project and maintains other necessary files such as JavaScript, CSS, and images of your project. |
| resources | The resources directory holds all the Sass files, language (localization) files, and templates (if any).                                       |
| routes    | The routes directory contains all your definition files for routing, such as console.php, api.php, channels.php, etc.                          |
| storage   | The storage directory holds your session files, cache, compiled templates, and miscellaneous files generated by the framework.                 |
| test      | The test directory holds all your test cases.                                                                                                  |
| vendor    | The vendor directory holds all composer dependency files.                                                                                      |

- You will need the `.env` file in the project's root directory to configure your application's environment. You can configure the database for your application using the `config/database.php` file of your project.

### App Directory Structure

| Directory     | Description                                                                                                                                                                                                                |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Console       | The Console directory contains all your project artisan commands.                                                                                                                                                          |
| Events        | The Events directory holds event files that your laravel application may pop up. Events are used for sending messages or signals to other parts of the laravel project that any action has taken place within the project. |
| Exceptions    | The Exceptions directory holds your laravel project's exception handling files, which handle all the exceptions thrown by your Laravel project.                                                                            |
| Http          | The Http directory holds different filters, requests, and controllers.                                                                                                                                                     |
| Jobs          | The Jobs directory holds all lineup jobs in this directory. But it does not get created initially; instead, you need to type and run this artisan command:`make:job`                                                       |
| Listeners     | The Listeners directory holds all your project's handler classes used for receiving and handling events.                                                                                                                   |
| Mail          | The Main directory holds all the emails sent through your Laravel project, and this directory needs to be created using the command: `make:mail`                                                                           |
| Notifications | The Notifications directory contains all your transactional notifications sent through your Laravel project, and this directory needs to be created using the command: `make:notification`                                 |
| Policies      | The policies directory holds different policies for your laravel project.                                                                                                                                                  |
| Providers     | The Providers directory is used to contain different service providers.                                                                                                                                                    |
| Rules         | The Rules directory holds all the different objects related to custom validation rules, and this directory needs to be created using the command: `make:rule`                                                              |

### Artisan

Artisan is a command-line interface (CLI) included with the Laravel PHP framework that provides several helpful commands for speeding up development workflows. use `php artisan list`
to see all commands.

> we can make our own commands and add them in artisan. first make scaffolding `php artisan make:command SendEmails` then implement your php codes in it.

## Routing

Routes are defined inside the Route folder in `api.php` and `web.php` files. in `api.php` we use to just use to return `JSON` in `API` formats.
Routing in Laravel allows you to route all your application requests to their appropriate controller. The application's route file gets defined in the `app/Http/routes.php` file. The general routing in Laravel for each of the possible requests looks something like this:

> Use `use Illuminate\Support\Facades\Route` in order to use routes in project.

![Routes in laravel](Laravel%20Images%20Reference/1.png)

```php
// http://localhost/
Route:: get ('/', function () {// '/' is the uri (means anything that comes after your root domain) and func is a controller that can be a method in our class or anonymous function!
   return view('Home');
})->('Home.index'); // this is how you can name your routes so they make sense by reading it

<!-- Another Example -->
// Defining a route that only renders a Blade template
Route::view('/Home'); // Without parameters
Route::view('/Home', ['data' => 'value']); // With parameters
```

- Roots that just returns HTML and don't require any parameters or any extra work, you can simplify like bellow:

```php
<!-- Before -->
Route::get('/', function() {
    return view('home,index', [])
})=>name('home.index');

<!-- After -->
Route::view('/', 'home.index')=>name('home.index');
```

- `php artisan route:list` Command shows all of routes in our project.

### The routing happens in three different steps

1. First of all, you have to create and run the root URL of your project.
2. The URL you run needs to be matched exactly with your method defined in the root.php file.
3. The function invokes the template files. It then calls the `view()` function with the file name located in `resources/views/`.

- It is good to know that routes have 4 functionalities like :`get()`,`post()`,`put()` and `delete()`.

![Route-functionalities](Laravel%20Images%20Reference/2.png)

#### Route Parameters

Laravel provides two ways of capturing the passed parameter:

- Required parameter (can be used for ids, postNumbers, ...): You sometimes had to work with a segment(s) of your project's URL (Uniform Resource Locator). Route parameters are encapsulated within {} (curly-braces) with alphabets inside. Let us take an example where you have to capture the customer's ID or employee from the generated URL. For Example:

```php
Route::get("posts/{id}", function ($id) {
  echo "Blog post " . $id;
});
```

- Optional Parameter (can be useful for time when name parameter is not provided): Many parameters do not remain present within the URL, but the developers had to use them. So such parameters get indicated by a "?" (question mark sign) following the parameter's name. For Example:

```php
Route::get("emp/{name?}", function ($name = "Guest") {
  echo $name;
});
Route::get("/recent-posts/{days_ago?}", function ($daysAgo = 20) {
  // it is necessary to have argument in optional parameters.
  return "Posts from " . $daysAgo . " days ago";
});
```

> Note - always name your routes! It is always wise to name our blade templates (views) as routes connected to them! Happy Coding.

In last Example the required parameter have to be a number, we can specify in route so it always be a number like Example bellow:

```php
Route :: get ('posts/{id}', function ($id) {
    echo 'Blog post '.$id;
})-> where([
    'id' => [0-9]+ // by using regular expressions. + means it should have a length of at least 1.
])->name('posts.show'); // don't forget to name your routes :)
```

> Note - we all know that ids are always a number. we should not always write `where(['id' => [0-9]+])`. To avoid repeating the code we do it in global, editing `app/provider/RouteServiceProvider.php` by adding repeated code as a pattern in line 49. For Example:`Route::pattern('id', '[0-9]+');`

## Views and Layouts

A view is a file containing a mix of PHP code, HTML markup, and Blade templates. These templates contain placeholders for dynamic content and are used to define the structure and layout of a web page. By default, Laravel comes with a set of predefined views, such as `welcome.blade.php` and `errors/404.blade.php`.

> Note: Views are stored in the `resources/views`.

### Creating a View

To create a view in Laravel, follow these steps:

1. Navigate to the `resources/views` directory in your Laravel project.
2. Create a new file with a `fileName.blade.php` extension. This extension tells Laravel to use the Blade template engine to parse the view.
3. In the view file, add the HTML, PHP, and/or Blade templates that define the structure and layout of the page. You can use placeholders for dynamic content, such as or.

For Example:

```php
<!-- resources/views/greeting.blade.php -->

<h1>Hello, {{$name}}!</h1> // $name is a placeholder for dynamic content
```

### Rendering a View

**View helper functions** can be used to display a view in a Laravel application. This function takes the name of the view as its first argument and an array of data as its second argument. For Example:

```php
// in a Laravel controller
return view("greeting", ["name" => "Alex"]);

// in routes/greeting.php
Route::get("/greeting", function () {
  return view("greeting", ["name" => "Alex"]);
});
```

As an alternative to passing a complete array of data to the view helper function, you may use the with method to add individual pieces of data to the view.

```php
return view('greeting')
            ->with('name', 'Victoria')
            ->with('occupation', 'Astronaut');
// or
<!-- web.php -->
Route::get('/posts/{id}', function($id){
    $posts = [
        1 => [
            'title' => 'Intro To laravel',
            'content' => 'This is a short intro to laravel'
        ],
        2 => [
            'title' => 'Intro to PHP',
            'content' => 'This is a short intro to PHP'
        ]
    ];
    abort_if(!isset($posts[$id]), 404); // this is a laravel helper function - generate an error (here is 404 not found) when this condition (inputted post id is not available) is met.
    return view('posts.show', ['post' => $posts[$id]]);
    });
<!-- Resources/views/posts/show.blade.php explained more in ### Layouts Usage -->
@extends('layouts.app')

@section('title', $post['title'])

@section('content')
<h1>{{ $post['title'] }}</h1>
<p>{{ $post['content'] }}</p>
@endsection
```

> "Dot" notation may be used to reference nested views. For example, if your view is stored at `resources/views/admin/profile.blade.php`, you may return it from one of your application's routes / controllers like so: `return view('admin.profile', $data);`
> Note: View directory names should not contain the `.` character.

### Sharing Data With All Views

Occasionally, you may need to share data with all views that are rendered by your application. You may do so using the `View` facade's `share` method in `App\Providers\AppServiceProvider`.

```php
namespace App\Providers;

use Illuminate\Support\Facades\View;

class AppServiceProvider extends ServiceProvider
{
  /**
   * Register any application services.
   */
  public function register(): void
  {
    // ...
  }

  /**
   * Bootstrap any application services.
   */
  public function boot(): void
  {
    View::share("key", "value");
  }
}
```

<!--
### View Composers

View composers are callbacks or class methods that are called when a view is rendered. If you have data that you want to be bound to a view each time that view is rendered, a view composer can help you organize that logic into a single location. View composers may prove particularly useful if the same view is returned by multiple routes or controllers within your application and always needs a particular piece of data.

Typically, view composers will be registered within one of your application's [service providers](/docs/{{version}}/providers). In this example, we'll assume that we have created a new `App\Providers\ViewServiceProvider` to house this logic.

We'll use the `View` facade's `composer` method to register the view composer. Laravel does not include a default directory for class based view composers, so you are free to organize them however you wish. For example, you could create an `app/View/Composers` directory to house all of your application's view composers:

```php
namespace App\Providers;

use App\View\Composers\ProfileComposer;
use Illuminate\Support\Facades;
use Illuminate\Support\ServiceProvider;
use Illuminate\View\View;

class ViewServiceProvider extends ServiceProvider
{
  /**
   * Register any application services.
   */
  public function register(): void
  {
    // ...
  }

  /**
   * Bootstrap any application services.
   */
  public function boot(): void
  {
    // Using class based composers...
    Facades\View::composer("profile", ProfileComposer::class);

    // Using closure based composers...
    Facades\View::composer("welcome", function (View $view) {
      // ...
    });

    Facades\View::composer("dashboard", function (View $view) {
      // ...
    });
  }
}
``` -->

### Layouts Usage

while coding a site there is always a chance that we are using the same html or any frontend code over and over, layouts simplify this method using directives like `@yield`. Directives always start with an at sign like `@` followed by the directive name and optionally they can have arguments.

- Yield Directive - The Yields Directive takes the name of the section it should render in the layout file, Using `@extends(`layout_file_name`)` and `@section('content')` ends with `@endsection`. Now, inside these two section directives, you can put all the HTML and content that should be rendered from.
  > Note: Layouts are stored in the `resources/layouts`. For Example:

```php
<!-- in resources/views/layouts/app.blade.php -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laravel App - @yield('title')</title>
</head>
<body>
    <div>
        @yield('content')
    </div>
</body>
</html>

<!-- in resources/views/index.blade.php or any other place we want to use `app.blade.php` as our layout -->
@extends('layouts.app')

@section('title', 'Home Page')

@section('content')
<h1>Hello World</h1>
@endsection
```

### Conditional Rendering

Sometimes our templates need some logic, for example, only if certain condition is true, you want to display some content, like is user logged in?

```php
Route::get('/posts/{id}', function($id){
    $post = [
        1 => [
            'title' => 'Intro To laravel',
            'content' => `This is a short intro to laravel`,
            'is_new' => true
        ],
        2 => [
            'title' => 'Intro to PHP',
            'content' => 'This is a short intro to PHP',
            'is_new' => false
        ]
    ];
    abort_if(!isset($post[$id]), 404);
    return view('posts.show', ['post' => $post[$id]]);
    });

<!-- show.blade.php to render content based on a condition, we will use the if directive. -->

@extends('layouts.app')

@section('title', $post['title'])

@section('content')
@if($post['is_new'])
<div>A new blog post, using if</div>
@elseif(!$post['is_new'])
<div> Blog post is old</div>
@endif
<h1>{{ $post['title'] }}</h1>
<p>{{ $post['content'] }}</p>
@endsection
```

- alternatively, to use Conditional Rendering using right Directive called `@unless()` that condition has to be false and no other alternatives, then `endunless()`.

```php
<!-- in this example we use last question answered in `@unless()` condition. -->
@unless ($post['is_new'])
    <p>There is newer post using unless Directive</p>
@endunless
```

- we can also add comments using `isset()` Directive like bellow:

```php
@extends('layouts.app')

@section('title', $post['title'])

@section('content')

@unless ($post['is_new'])
    <p>There is newer post using unless Directive</p>
@endunless

@isset($post['has_comments'])
    <div>this post has some comments. using `isset()` directives</div>
@endisset
```

> there are more Directives that uses further laravel knowledge that we will add later.

#### loops

```php
@for ($i = 0; $i < 10; $i++)
    The current value is {{ $i }}
@endfor

@foreach ($users as $user)
    <p>This is user {{ $user->id }}</p>
@endforeach

@forelse ($users as $user)
    <li>{{ $user->name }}</li>
@empty
    <p>No users</p>
@endforelse

@while (true)
    <p>I'm looping forever.</p>
@endwhile
```

| Property           | Description                                            |
| ------------------ | ------------------------------------------------------ |
| `$loop->index`     | The index of the current loop iteration (starts at 0). |
| `$loop->iteration` | The current loop iteration (starts at 1).              |
| `$loop->remaining` | The iterations remaining in the loop.                  |
| `$loop->count`     | The total number of items in the array being iterated. |
| `$loop->first`     | Whether this is the first iteration through the loop.  |
| `$loop->last`      | Whether this is the last iteration through the loop.   |
| `$loop->even`      | Whether this is an even iteration through the loop.    |
| `$loop->odd`       | Whether this is an odd iteration through the loop.     |
| `$loop->depth`     | The nesting level of the current loop.                 |
| `$loop->parent`    | When in a nested loop, the parent's loop variable.     |

### Partial(sub view) Templates

Blade's @include directive allows you to include a Blade view from within another view, also helps you extract parts of your templates into smaller chunks, which is easier to manage in long term.

> All variables that are available to the parent view will be made available to the included view

## Requests & Response

Laravel has ways to build our proper HTTP response with all its features like response codes, setting cookies and setting response headers. Check Example bellow:

```php
Route::get("/fun/responses", function () use ($posts) {
  return response($posts, 201)
    ->header("Content-Type", "application/json")
    ->cookie("MY_COOKIE", "Fard", 3600);
});
```

the response function will create a new response object. This object has methods like header or cookie.

- The response function accepts the Three parameters, all optional, first is the content to return, Second, the status code and third is an array of response headers.

So posts will be a content and 201 in our response code. The Header method sets the response header like contents type, telling the browser what to expect from their content, whether it is HTML or JSON. Cookie sets the browser cookies. Cookies are useful to keep users specific data on the browser side. we can render blade views while adding headers cookies and changing the status code.

### Redirect Responses

Sometimes the route needs to do something and then go to another page. For example:

```php
Route::get("/fun/redirect", function () {
  return redirect("/contact");
});
```

The `back` helper function will redirect to the last address. It's useful with one time actions like for input storying. For example:

```php
Route::get("/fun/back", function () {
  return back();
});
```

Sometimes you need to return only the data from the response without any HTML and in such cases most of the time you wanted in the Json format. For example:

```php
Route::get("/fun/json", function () use ($posts) {
  return response()->json($posts);
});
```

It's easy to force the browser to download a file, using the download method of the response object.

```php
Route::get("/fun/download", function () {
  return response()->download(
    public_path("/chingcho Chang.jpg"),
    "ChingChoChang.jpg"
  );
});
```

### Group Routes

Group Routes can have the same prefix, the same roots, name prefix or the same middleware applied.

```php
Route::prefix("/fun")
  ->name("fun.")
  ->group(function () use ($posts) {
    // Testing Requests & Response
    Route::get("responses", function () use ($posts) {
      return response($posts, 201)
        ->header("Content-Type", "application/json")
        ->cookie("MY_COOKIE", "Fard", 3600);
    })->name("responses");
    Route::get("redirect", function () {
      return redirect("/contact");
    })->name("redirect");
    Route::get("back", function () {
      return back();
    })->name("back");
    Route::get("named-route", function () {
      return redirect()->route("posts.show", ["id" => 1]);
    })->name("named-route");
    Route::get("away", function () {
      return redirect()->away("https://google.com");
    })->name("away");
    Route::get("json", function () use ($posts) {
      return response()->json($posts);
    })->name("json");
    Route::get("download", function () {
      return response()->download(
        public_path("/chingcho Chang.jpg"),
        "ChingChoChang.jpg"
      );
    })->name("download");
  });
```

### Request Input

Apart from the root parameters, we can accept input as the Query parameters data sent through an HTML form or request body interface and `Json` format. This Input is accessible using the request object methods. There are two ways

- using the request function `request()`.
- by type printing argument with the request `function(Request $request)`.

> Make sure to use `use Illuminate\Http\Request;`

#### `request()->all()` Method

The `all()` method will give us access to all the inputs (as an array), but not the actual route parameters.
for example:

let's Try adding some query parameters like page and limit, often used as results`127.0.0.1:8000/posts?limit=10&page=5`. In order to see the results we use `dd()` function.

- `dd()` can be used to dump data.

```php
Route::get("/posts", function () use ($posts) {
  dd(request()->all());
  return view("posts.index", ["posts" => $posts]);
});
```

we can also use `dd(request()->input('page', 1));` to allows us to specify a default value to ask the second parameter. there is a special query method if you want to get the value only from a query parameter `dd((int)request()->query('page', 1));`. works the same as the input method does. input will look for the names in all the possible input. Sources like Query Parameters, a form or Jason and query.

### Middleware

Middleware is a mechanism that filter requests going through your application.

![Request flow with middleware](Laravel%20Images%20Reference/3.png)

An example BEFORE middleware

```php
namespace App\Http\Middleware;
use Closure;

class BeforeMiddleware
{
  public function handle($request, Closure $next)
  {
    // Do something here before the request is handled by Controller/Closure...

    // Calling $next with $request parameter
    return $next($request);
  }
}
```

An example AFTER middleware

```php
namespace App\Http\Middleware;
use Closure;

class AfterMiddleware
{
  public function handle($request, Closure $next)
  {
    // Calling $next with $request parameter
    $response = $next($request);

    // Do something here after the request is handled by Controller/Closure
    return $response;
  }
}
```

Middleware should call the passed `Closure` `$next` with the `$request` parameter to allow further processing, or `throw` an `Exception` or do a redirect to stop further processing of the `Request`.

Middleware examples:

- Authentication (verifying if user is authenticated)
- CSRF protection
- CORS middleware

![Middleware](Laravel%20Images%20Reference/4.png)

One of the Route object methods is middleware. we can apply to a group of routes or a specific route. in `kernel.php` file there is `$routeMiddleware` and inside it defines a thing called Elias, Now using this, you can easily apply middleware using the middleware method and passing those. Like below:

```php
Route::get("/posts/{id}", function ($id) use ($posts) {
  abort_if(!isset($posts[$id]), 404);

  return view("posts.show", ["post" => $posts[$id]]);
})
  ->name("posts.show")
  ->middleware("auth"); //the user needs to be authenticated to visit this route.
```

## Controllers

Controllers are an alternative to Closures for defining the application logic

![Controllers](Laravel%20Images%20Reference/5.png)

- To Generating a new Controller `php artisan make:controller ControllerNameController`.

> Controllers are stored inside the `app/Http/Controllers` folder.

An example controller class

```php
<!-- In Controller -->
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;

class HomeController extends Controller
{
  public function index()
  {
    return view("home");
  }

  public function contact()
  {
    return view("contact");
  }
}

<!-- In Routes -->
Route::get("/", "HomeController@home");
// or
Route::get('/', [HomeController::class, 'home'])->name('home.index');

Route::get("/contact", "HomeController@contact");
//or
Route::get('/contact', [HomeController::class, 'contact'])->name('home.contact');
```

We don't have to specify the full controller namespace in `web.php`. It's enough to specify everything after `App\Http\Controllers`. RouteServiceProvider will is responsible for prepending the `App\Http\Controllers` namespace to controller names in routes.

### Single Action Controllers

For controllers that handle just a single action:

- `php artisan make:controller HomeSingleController --invokable`

```php
<!-- In Controller -->
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;

class HomeSingleController extends Controller
{
  public function __invoke()
  {
    return view("home");
  }
}

<!-- In Routes -->
Route::get("home", "HomeSingleController");
// or
Route::get('/single', HomeSingleController::class);

```

The `__invoke` is a magic PHP method that allows the object to be called like a function, eg.

```php
$controller = new HomeSingleController();
$controller();
```

![Controller](Laravel%20Images%20Reference/5.png)
